#!/bin/sh
# Git hook script para executar verifica√ß√µes antes do commit
# Este script executa verifica√ß√µes de qualidade no c√≥digo que ser√° commitado

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

echo "${BLUE}üîç Executando verifica√ß√µes pre-commit...${NC}"

# Fun√ß√£o para imprimir erro e sair
print_error() {
    echo "${RED}‚ùå $1${NC}"
    exit 1
}

# Fun√ß√£o para imprimir sucesso
print_success() {
    echo "${GREEN}‚úÖ $1${NC}"
}

# Fun√ß√£o para imprimir aviso
print_warning() {
    echo "${YELLOW}‚ö†Ô∏è $1${NC}"
}

# Verificar se h√° arquivos staged
check_staged_files() {
    if git diff --cached --quiet; then
        print_error "Nenhum arquivo staged para commit"
    fi
}

# Verificar arquivos Python staged
get_staged_python_files() {
    git diff --cached --name-only --diff-filter=ACM | grep -E '\.(py)$'
}

# Verificar arquivos de configura√ß√£o staged
get_staged_config_files() {
    git diff --cached --name-only --diff-filter=ACM | grep -E '\.(yaml|yml|json|ini|cfg|toml)$'
}

# Verificar arquivos de documenta√ß√£o staged
get_staged_doc_files() {
    git diff --cached --name-only --diff-filter=ACM | grep -E '\.(md|rst|txt)$'
}

# Verificar formata√ß√£o do c√≥digo Python
check_python_formatting() {
    staged_files=$(get_staged_python_files)
    
    if [ -z "$staged_files" ]; then
        return 0
    fi
    
    echo "${BLUE}üêç Verificando formata√ß√£o Python...${NC}"
    
    # Verificar com black
    if command -v black >/dev/null 2>&1; then
        echo "$staged_files" | xargs python3 -m black --check --quiet 2>/dev/null
        if [ $? -ne 0 ]; then
            print_warning "C√≥digo Python n√£o est√° formatado corretamente"
            echo "Execute: black $staged_files"
            
            # Oferecer corre√ß√£o autom√°tica
            read -p "Deseja formatar automaticamente? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "$staged_files" | xargs python3 -m black
                echo "$staged_files" | xargs git add
                print_success "C√≥digo formatado e re-staged"
            else
                print_error "Formate o c√≥digo manualmente e tente novamente"
            fi
        fi
    fi
    
    # Verificar imports com isort
    if command -v isort >/dev/null 2>&1; then
        echo "$staged_files" | xargs python3 -m isort --check-only --quiet 2>/dev/null
        if [ $? -ne 0 ]; then
            print_warning "Imports Python n√£o est√£o organizados"
            echo "Execute: isort $staged_files"
            
            # Oferecer corre√ß√£o autom√°tica
            read -p "Deseja organizar imports automaticamente? (y/N): " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                echo "$staged_files" | xargs python3 -m isort
                echo "$staged_files" | xargs git add
                print_success "Imports organizados e re-staged"
            else
                print_error "Organize os imports manualmente e tente novamente"
            fi
        fi
    fi
    
    print_success "Formata√ß√£o Python OK"
}

# Verificar linting do c√≥digo Python
check_python_linting() {
    staged_files=$(get_staged_python_files)
    
    if [ -z "$staged_files" ]; then
        return 0
    fi
    
    echo "${BLUE}üîç Verificando linting Python...${NC}"
    
    # Verificar com flake8
    if command -v flake8 >/dev/null 2>&1; then
        echo "$staged_files" | xargs python3 -m flake8 --max-line-length=100 --ignore=E203,W503
        if [ $? -ne 0 ]; then
            print_error "Problemas de linting encontrados. Corrija-os antes do commit"
        fi
    fi
    
    # Verificar com mypy (se configurado)
    if command -v mypy >/dev/null 2>&1 && [ -f "mypy.ini" ]; then
        echo "$staged_files" | xargs python3 -m mypy --ignore-missing-imports
        if [ $? -ne 0 ]; then
            print_warning "Problemas de tipo encontrados"
        fi
    fi
    
    print_success "Linting Python OK"
}

# Verificar sintaxe dos arquivos de configura√ß√£o
check_config_syntax() {
    staged_files=$(get_staged_config_files)
    
    if [ -z "$staged_files" ]; then
        return 0
    fi
    
    echo "${BLUE}‚öôÔ∏è Verificando sintaxe de configura√ß√£o...${NC}"
    
    for file in $staged_files; do
        case "$file" in
            *.yaml|*.yml)
                if command -v python3 >/dev/null 2>&1; then
                    python3 -c "import yaml; yaml.safe_load(open('$file'))" 2>/dev/null
                    if [ $? -ne 0 ]; then
                        print_error "Sintaxe YAML inv√°lida em $file"
                    fi
                fi
                ;;
            *.json)
                if command -v python3 >/dev/null 2>&1; then
                    python3 -c "import json; json.load(open('$file'))" 2>/dev/null
                    if [ $? -ne 0 ]; then
                        print_error "Sintaxe JSON inv√°lida em $file"
                    fi
                fi
                ;;
        esac
    done
    
    print_success "Sintaxe de configura√ß√£o OK"
}

# Verificar secrets expostos
check_secrets() {
    echo "${BLUE}üîí Verificando secrets expostos...${NC}"
    
    # Verificar padr√µes comuns de secrets
    secrets_patterns="password|secret|key|token|api_key|private_key"
    
    staged_files=$(git diff --cached --name-only)
    for file in $staged_files; do
        if git show ":$file" | grep -iE "$secrets_patterns" >/dev/null 2>&1; then
            # Verificar se n√£o √© apenas documenta√ß√£o ou exemplo
            if ! echo "$file" | grep -E '\.(md|rst|txt|example)$' >/dev/null; then
                print_warning "Poss√≠vel secret detectado em $file"
                git show ":$file" | grep -iE "$secrets_patterns" | head -5
                
                read -p "Continuar mesmo assim? (y/N): " -n 1 -r
                echo
                if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                    print_error "Commit cancelado para verificar secrets"
                fi
            fi
        fi
    done
    
    # Usar detect-secrets se dispon√≠vel
    if command -v detect-secrets >/dev/null 2>&1; then
        detect-secrets scan --baseline .secrets.baseline $(git diff --cached --name-only) >/dev/null 2>&1
        if [ $? -ne 0 ]; then
            print_warning "Poss√≠veis secrets detectados pelo detect-secrets"
            
            read -p "Continuar mesmo assim? (y/N): " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_error "Commit cancelado. Verifique com: detect-secrets scan"
            fi
        fi
    fi
    
    print_success "Verifica√ß√£o de secrets OK"
}

# Verificar tamanho dos arquivos
check_file_sizes() {
    echo "${BLUE}üìÅ Verificando tamanho dos arquivos...${NC}"
    
    staged_files=$(git diff --cached --name-only)
    large_files=""
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null)
            if [ "$size" -gt 5242880 ]; then  # 5MB
                large_files="$large_files $file ($(($size / 1024 / 1024))MB)"
            fi
        fi
    done
    
    if [ -n "$large_files" ]; then
        print_warning "Arquivos grandes detectados:$large_files"
        print_warning "Considere usar Git LFS para arquivos grandes"
        
        read -p "Continuar mesmo assim? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Commit cancelado. Configure Git LFS se necess√°rio"
        fi
    fi
    
    print_success "Verifica√ß√£o de tamanho OK"
}

# Verificar conven√ß√µes de nome de arquivo
check_filename_conventions() {
    echo "${BLUE}üìÑ Verificando conven√ß√µes de nomenclatura...${NC}"
    
    staged_files=$(git diff --cached --name-only)
    
    for file in $staged_files; do
        # Verificar se o nome do arquivo tem espa√ßos
        if echo "$file" | grep " " >/dev/null; then
            print_warning "Arquivo com espa√ßos no nome: $file"
        fi
        
        # Verificar se o nome do arquivo tem caracteres especiais
        if echo "$file" | grep -E '[^a-zA-Z0-9._/-]' >/dev/null; then
            print_warning "Arquivo com caracteres especiais: $file"
        fi
        
        # Verificar extens√µes Python
        if echo "$file" | grep -E '\.py$' >/dev/null; then
            if ! echo "$file" | grep -E '^[a-z_][a-z0-9_]*\.py$' >/dev/null; then
                basename_file=$(basename "$file")
                if ! echo "$basename_file" | grep -E '^[a-z_][a-z0-9_]*\.py$' >/dev/null; then
                    print_warning "Nome de arquivo Python n√£o segue conven√ß√£o snake_case: $file"
                fi
            fi
        fi
    done
    
    print_success "Conven√ß√µes de nomenclatura OK"
}

# Verificar se h√° conflitos de merge
check_merge_conflicts() {
    echo "${BLUE}üîÄ Verificando conflitos de merge...${NC}"
    
    staged_files=$(git diff --cached --name-only)
    
    for file in $staged_files; do
        if git show ":$file" | grep -E '^(<{7}|={7}|>{7})' >/dev/null 2>&1; then
            print_error "Marcadores de conflito de merge encontrados em $file"
        fi
    done
    
    print_success "Nenhum conflito de merge encontrado"
}

# Verificar encoding dos arquivos
check_file_encoding() {
    echo "${BLUE}üî§ Verificando encoding dos arquivos...${NC}"
    
    staged_files=$(git diff --cached --name-only)
    
    for file in $staged_files; do
        if [ -f "$file" ]; then
            # Verificar se √© texto e tem BOM UTF-8
            if file "$file" | grep -q "UTF-8" && xxd -l 3 "$file" | grep -q "efbbbf"; then
                print_warning "Arquivo com BOM UTF-8 detectado: $file"
            fi
            
            # Verificar se √© arquivo de texto com encoding n√£o-UTF-8
            if file "$file" | grep -q "text" && ! file "$file" | grep -q "UTF-8"; then
                print_warning "Arquivo de texto com encoding n√£o-UTF-8: $file"
            fi
        fi
    done
    
    print_success "Encoding dos arquivos OK"
}

# Executar testes r√°pidos nos arquivos modificados
run_quick_tests() {
    staged_python_files=$(get_staged_python_files)
    
    if [ -z "$staged_python_files" ]; then
        return 0
    fi
    
    echo "${BLUE}‚ö° Executando testes r√°pidos...${NC}"
    
    # Verificar sintaxe Python
    for file in $staged_python_files; do
        python3 -m py_compile "$file" 2>/dev/null
        if [ $? -ne 0 ]; then
            print_error "Erro de sintaxe Python em $file"
        fi
    done
    
    # Executar testes unit√°rios relacionados (se existirem)
    if [ -d "tests/unit" ]; then
        for file in $staged_python_files; do
            # Buscar arquivo de teste correspondente
            test_file="tests/unit/test_$(basename "$file")"
            if [ -f "$test_file" ]; then
                python3 -m pytest "$test_file" -q --tb=no >/dev/null 2>&1
                if [ $? -ne 0 ]; then
                    print_warning "Testes falharam para $file"
                fi
            fi
        done
    fi
    
    print_success "Testes r√°pidos OK"
}

# Fun√ß√£o principal
main() {
    echo "${BLUE}üìã Iniciando verifica√ß√µes pre-commit...${NC}"
    
    # Verifica√ß√µes b√°sicas
    check_staged_files
    check_merge_conflicts
    check_file_sizes
    check_filename_conventions
    check_file_encoding
    
    # Verifica√ß√µes espec√≠ficas por tipo de arquivo
    check_config_syntax
    check_python_formatting
    check_python_linting
    
    # Verifica√ß√µes de seguran√ßa
    check_secrets
    
    # Testes r√°pidos
    run_quick_tests
    
    echo "${GREEN}üéâ Todas as verifica√ß√µes pre-commit passaram!${NC}"
}

# Fun√ß√£o para bypass em emerg√™ncia
emergency_bypass() {
    if [ "$EMERGENCY_COMMIT" = "true" ]; then
        print_warning "BYPASS DE EMERG√äNCIA ATIVADO!"
        print_warning "Use apenas em situa√ß√µes cr√≠ticas"
        exit 0
    fi
}

# Verificar bypass de emerg√™ncia
emergency_bypass

# Verificar se deve pular verifica√ß√µes
if [ "$SKIP_HOOKS" = "true" ]; then
    print_warning "Hooks desabilitados via SKIP_HOOKS=true"
    exit 0
fi

# Verificar se pre-commit framework est√° dispon√≠vel
if command -v pre-commit >/dev/null 2>&1 && [ -f ".pre-commit-config.yaml" ]; then
    echo "${BLUE}üîß Executando pre-commit framework...${NC}"
    pre-commit run --files $(git diff --cached --name-only)
    if [ $? -ne 0 ]; then
        print_error "Pre-commit framework falhou"
    fi
else
    # Executar verifica√ß√µes manuais
    main
fi

# Se chegou at√© aqui, tudo OK
exit 0
